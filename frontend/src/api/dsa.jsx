export const dsaData = {
  title: "Data Structures & Algorithms",
  concepts: [
    {
      id: "whatIsDsa",
      title: "Data Structures & Algorithms",
      subtitle: "Master the foundation of computer science with comprehensive DSA concepts",
      description: "Learn deeply. Code efficiently. Crack interviews.",
      hero: {
        tagline: "Have you ever wondered why some apps load instantly, while others lag and freeze?",
        introduction: "The secret lies not in the speed of your phone, but in the invisible architecture that organizes the data behind the scenes. This architecture is called a data structure.",
        impact: "Every second, applications like Google Maps process billions of location points and Twitter handles millions of real-time tweets, all thanks to the right data structures."
      },
      realWorldScenarios: [
        {
          category: "Consumer Experience",
          title: "Music Streaming",
          description: "When you swipe through your playlist on Spotify, you're interacting with a data structure that organizes songs, artists, and albums. The efficiency with which the app finds and plays your next song is a direct result of how this data is structured.",
          impact: "Poor organization would make every swipe feel like a chore",
          icon: "üéµ"
        },
        {
          category: "Business Impact",
          title: "E-commerce Giants",
          description: "E-commerce giants like Amazon use data structures to manage millions of products, customer orders, and shipping information.",
          impact: "Using the right data structure allows them to process transactions, track inventory, and recommend products at a massive scale, saving millions in operational costs and increasing revenue.",
          icon: "üõí"
        },
        {
          category: "Scientific Breakthrough",
          title: "CERN Research",
          description: "Scientists at CERN use data structures to handle the massive amounts of data generated by particle collisions.",
          impact: "Without efficient data structures, they would not be able to process this information quickly enough to make groundbreaking discoveries, such as the Higgs boson.",
          icon: "üî¨"
        },
        {
          category: "Social Impact",
          title: "Social Media Platforms",
          description: "Data structures are the foundation of social media platforms like Facebook. They manage friend lists, message histories, and news feeds.",
          impact: "The way this data is structured can even influence the speed at which information spreads.",
          icon: "üì±"
        }
      ],
      multiSensoryHooks: {
        visual: {
          title: "Visual Hook",
          description: "Imagine a cluttered desk with papers piled everywhere versus a perfectly organized filing cabinet. The filing cabinet is a data structure for papers.",
          animation: "animations of data being added to a disorganized pile versus being perfectly placed in an organized structure"
        },
        auditory: {
          title: "Auditory Hook",
          description: "A jarring sound of things falling over üí• represents unorganized data. A clean, satisfying click üóÇÔ∏è represents data being efficiently stored."
        },
        kinesthetic: {
          title: "Kinesthetic Hook",
          description: "You can physically represent a data structure by using your hands. Imagine a list of items where you must move each item one by one to find something at the end (an array). Then, imagine a chain where each link points to the next (a linked list)."
        },
        narrative: {
          title: "Narrative Hook",
          description: "A librarian is given the task of organizing a new library. If they just stack books randomly, finding a specific book would be a nightmare. But if they create a system‚Äîorganizing by genre, then author, then title‚Äîthey've created a data structure for books."
        }
      },
      curiosityGaps: [
        "Why does it matter if my data is a mess if I can still access it?",
        "What's the difference between a simple variable and a data structure?",
        "How can data be 'structured' in a way that speeds up a program?",
        "Why is a simple list of items not always the best way to store information?",
        "What's the 'secret sauce' that allows Google Maps to calculate the fastest route almost instantly?",
        "How can organizing data save a company millions of dollars?",
        "What happens if you choose the wrong data structure?"
      ],
      codeExamples: [
        {
          level: 1,
          title: "Basic Implementation (Array)",
          description: "This code shows how to store data in a simple array.",
          language: "c",
          code: "#include <stdio.h>\n\nint main() {\n    int numbers[5] = {10, 20, 30, 40, 50};\n    printf(\"The third element is: %d\\n\", numbers[2]);\n    int target = 30;\n    int found_index = -1;\n    for (int i = 0; i < 5; i++) {\n        if (numbers[i] == target) {\n            found_index = i;\n            break;\n        }\n    }\n    if (found_index != -1) {\n        printf(\"Found %d at index %d.\\n\", target, found_index);\n    } else {\n        printf(\"%d not found.\\n\", target);\n    }\n    return 0;\n}",
          concepts: ["Array declaration", "Index-based access", "Linear search", "Memory allocation"]
        },
        {
          level: 2,
          title: "Intermediate Implementation (Linked List Node)",
          description: "This code introduces the concept of a linked list, a more dynamic data structure.",
          language: "c",
          code: "#include <stdio.h>\n#include <stdlib.h>\nstruct Node {\n    int data;\n    struct Node* next;\n};\nint main() {\n    struct Node* head = (struct Node*)malloc(sizeof(struct Node));\n    struct Node* second = (struct Node*)malloc(sizeof(struct Node));\n    struct Node* third = (struct Node*)malloc(sizeof(struct Node));\n    head->data = 10;\n    head->next = second;\n    second->data = 20;\n    second->next = third;\n    third->data = 30;\n    third->next = NULL;\n    printf(\"Linked list elements: \\n\");\n    struct Node* current = head;\n    while (current != NULL) {\n        printf(\"%d ‚Üí \", current->data);\n        current = current->next;\n    }\n    printf(\"NULL\\n\");\n    free(head);\n    free(second);\n    free(third);\n    return 0;\n}",
          concepts: ["Struct definition", "Pointers", "Dynamic memory allocation", "Linked list traversal", "Memory management"]
        },
        {
          level: 3,
          title: "Advanced Implementation (Simple Linked List Functions)",
          description: "This code builds on Level 2 by introducing functions to insert a new node at the beginning of the list.",
          language: "c",
          code: "#include <stdio.h>\n#include <stdlib.h>\nstruct Node {\n    int data;\n    struct Node* next;\n};\nvoid printList(struct Node* node) {\n    while (node != NULL) {\n        printf(\"%d ‚Üí \", node->data);\n        node = node->next;\n    }\n    printf(\"NULL\\n\");\n}\nvoid push(struct Node** head_ref, int new_data) {\n    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));\n    new_node->data = new_data;\n    new_node->next = (*head_ref);\n    (*head_ref) = new_node;\n}\nint main() {\n    struct Node* head = NULL;\n    push(&head, 10);\n    push(&head, 20);\n    push(&head, 30);\n    printf(\"Created linked list: \\n\");\n    printList(head);\n    struct Node* current = head;\n    while(current != NULL) {\n        struct Node* temp = current;\n        current = current->next;\n        free(temp);\n    }\n    return 0;\n}",
          concepts: ["Function definitions", "Pointer to pointer", "Insert at beginning", "Memory cleanup", "Modular programming"]
        }
      ],
      interactiveElements: [
        {
          type: "Parameter Playground",
          description: "A visual array where students can type in numbers..."
        },
        {
          type: "What-If Scenarios",
          examples: [
            "What if you tried to access numbers[10] in an array of size 5? What happens?",
            "What if the first node in a linked list had a NULL pointer?"
          ]
        },
        {
          type: "Break-It Challenges",
          description: "Students are given a basic linked list implementation..."
        },
        {
          type: "Performance Laboratory",
          description: "A tool where students can input the size of an array..."
        }
      ],
      visualSimulations: {
        microLevel: "An animated diagram shows a single piece of data...",
        macroLevel: "A flowchart demonstrates the process of adding...",
        metaLevel: "A graph shows how the time to find an element...",
        comparativeLevel: "Side-by-side animations of adding an element..."
      },
      explorationPrompts: [
        { type: "Pattern Recognition", question: "What pattern do you notice..." },
        { type: "Prediction", question: "What do you think will happen..." },
        { type: "Comparison", question: "How does the next pointer..." },
        { type: "Optimization", question: "In the linear search example..." },
        { type: "Edge Cases", question: "What happens in the array..." }
      ],
      conceptArchitecture: {
        coreEssence: "A data structure is a specialized format...",
        detailedMechanics: {
          storage: "How data is physically laid out...",
          access: "How we retrieve specific pieces...",
          manipulation: "How we add, remove, or modify..."
        },
        mathematicalFoundation: {
          bigONotation: "Data structures are often analyzed...",
          examples: {
            "O(1)": "Constant time...",
            "O(n)": "Linear time..."
          }
        },
        terminology: {
          dataStructure: "A way of organizing...",
          algorithm: "A step-by-step...",
          array: "A data structure that stores...",
          linkedList: "A linear data structure...",
          node: "A basic unit...",
          pointer: "A variable that stores...",
          linearSearch: "A simple algorithm...",
          memoryAddress: "The unique location...",
          contiguousMemory: "Memory locations that are next...",
          bigONotation: "A way to describe..."
        },
        mentalModels: [
          { name: "The Filing Cabinet", description: "An array is like a filing cabinet..." },
          { name: "The Treasure Map", description: "A linked list is like a treasure map..." },
          { name: "The Train Analogy", description: "An array is a train with a fixed number..." }
        ]
      },
      complexityAnalysis: {
        timeComplexity: {
          arrayAccess: { complexity: "O(1)", description: "Constant time..." },
          arrayInsertion: { complexity: "O(n)", description: "Linear time..." },
          linkedListAccess: { complexity: "O(n)", description: "Linear time..." },
          linkedListInsertion: { complexity: "O(1)", description: "Constant time..." }
        },
        spaceComplexity: {
          both: { complexity: "O(n)", description: "Both arrays and linked lists..." }
        },
        tradeoffs: "The central idea here is the Time-Space Trade-off..."
      },
      industryApplications: {
        technology: [
          { company: "Google", application: "Uses arrays for efficient data lookup...", icon: "üîç" },
          { company: "Facebook", application: "Utilizes graphs to represent...", icon: "üë•" },
          { company: "Netflix", application: "Uses various data structures...", icon: "üé¨" },
          { company: "Amazon", application: "Employs arrays and linked lists...", icon: "üì¶" }
        ],
        finance: [
          { sector: "High-Frequency Trading", application: "Data structures are used...", icon: "üìà" },
          { sector: "Banking Systems", application: "Arrays and linked lists manage...", icon: "üè¶" },
          { sector: "Cryptocurrency", application: "Blockchain is a specialized...", icon: "‚Çø" }
        ],
        healthcare: [
          { sector: "Medical Imaging", application: "Arrays are used to store pixel data...", icon: "üè•" },
          { sector: "Drug Discovery", application: "Complex data structures represent...", icon: "üíä" },
          { sector: "Genomics", application: "Data structures store DNA sequences...", icon: "üß¨" }
        ],
        transportation: [
          { sector: "Autonomous Vehicles", application: "Arrays store sensor data...", icon: "üöó" },
          { sector: "Route Optimization", application: "Graph data structures are used...", icon: "üó∫Ô∏è" },
          { sector: "Supply Chain", application: "Linked lists can be used...", icon: "üì¶" }
        ]
      },
      assessments: {
        knowledge: [
          {
            type: "multiple_choice",
            question: "What is a data structure?",
            options: [
              "A type of variable",
              "A specific way of organizing and storing data",
              "A programming language",
              "An algorithm"
            ],
            correct: 1,
            explanation: "A data structure is a specialized format..."
          },
          {
            type: "matching",
            question: "Match the term to its definition",
            pairs: [
              { term: "Array", definition: "A collection of fixed-size elements..." },
              { term: "Node", definition: "The basic unit of a linked list" },
              { term: "Pointer", definition: "A variable holding a memory address" },
              { term: "O(n)", definition: "A linear time complexity" }
            ]
          }
        ],
        application: [
          {
            type: "coding",
            question: "Write a C program to declare an integer array...",
            difficulty: "beginner"
          },
          {
            type: "code_completion",
            question: "Given a partially complete C program...",
            difficulty: "intermediate"
          }
        ],
        analysis: [
          {
            type: "case_study",
            question: "You are building a student management system...",
            difficulty: "advanced"
          }
        ]
      },
      portfolio: [
        { type: "GitHub Repository", description: "Create a well-documented GitHub repository..." },
        { type: "Technical Blog Post", description: "Write a blog post titled 'Why You Need to Know...'" },
        { type: "Video Explanation", description: "Record a short video where you walk through..." },
        { type: "Presentation", description: "Prepare a presentation on 'Introduction...'" }
      ],
      quantifiedImpact: {
        marketSize: "The global data management and analytics market...",
        efficiencyGains: "Using a hash table instead of a linear search...",
        jobCreation: "This foundational knowledge is a core requirement...",
        socialImpact: "Efficient data structures power crucial public services..."
      }
    },
    {
      id: "usesInIndustry",
      name: "Industry Applications of DSA",
      description: "Real-world examples of how data structures and algorithms are used.",
      definition: "DSA are not just theoretical concepts; they are the backbone of many modern software systems. From search engines to social media, these principles enable the efficient processing and management of large-scale data.",
      useCase: "Search Engines: Google's search algorithms use graphs and hash tables to index and retrieve web pages quickly.\nSocial Media: Platforms like Facebook and Twitter use graphs to model user connections and relationships.\nE-commerce: Sites like Amazon use sorting and searching algorithms to display products and manage inventory.\nDatabases: B-trees and B+ trees, which are types of tree data structures, are used for efficient database indexing.\nGaming: Pathfinding algorithms (like A*) are used in video games for character movement and AI.",
      code: null,
      questions: []
    },
    {
      id: "learningRoadmap",
      name: "Learning Roadmap for DSA",
      description: "A structured guide to learning Data Structures and Algorithms.",
      definition: "A systematic approach to learning DSA involves starting with the basics and progressively moving to more complex topics. This roadmap helps build a solid foundation and prepares you for real-world problem-solving.",
      useCase: "Begin with basic data structures: Arrays, Linked Lists, Stacks, and Queues.\nLearn core algorithms: Sorting (Bubble, Merge, Quick), Searching (Linear, Binary).\nMove to non-linear data structures: Trees (Binary Tree, BST), Graphs.\nStudy advanced topics: Heaps, Hash Maps, Tries, and dynamic programming.\nPractice consistently by solving problems on platforms like LeetCode or HackerRank.",
      code: null,
      questions: []
    },
    {
      id: "stack",
      name: "Stack",
      description: "A linear data structure that follows Last In First Out (LIFO) principle",
      definition: "A stack is a fundamental data structure that operates on the Last In, First Out (LIFO) principle. Elements are added and removed from the same end, called the top of the stack. Think of it like a stack of plates - you can only add or remove plates from the top.",
      useCase: "Stacks are widely used in web browsers for the back button functionality, in programming languages for function call management, in expression evaluation, and in undo operations in text editors. They're also crucial in algorithms like depth-first search and in parsing expressions.",
      code: "class Stack {\n  constructor() {\n    this.items = [];\n  }\n\n  push(element) {\n    this.items.push(element);\n  }\n\n  pop() {\n    if (this.isEmpty()) return null;\n    return this.items.pop();\n  }\n\n  peek() {\n    return this.items[this.items.length - 1];\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n}\n\n// Usage\nconst stack = new Stack();\nstack.push(10);\nstack.push(20);\nconsole.log(stack.peek()); // 20\nconsole.log(stack.pop());  // 20",
      questions: [
        {
          question: "How would you implement a stack using two queues?",
          hint: "Use one queue as main storage and another as temporary storage during pop operations",
          answer: "Use two queues. For push, add to queue1. For pop, move all but last element from queue1 to queue2, pop the last element, then swap the queues."
        },
        {
          question: "Design a stack that supports getMin() in O(1) time",
          hint: "Use an auxiliary stack to keep track of minimum elements",
          answer: "Maintain two stacks - one for data and another for minimums. Push to min stack only when new element is ‚â§ current minimum."
        }
      ]
    },
    {
      id: "queue",
      name: "Queue",
      description: "A linear data structure that follows First In First Out (FIFO) principle",
      definition: "A queue is a linear data structure that follows the First-In, First-Out (FIFO) principle. Elements are added at the back (enqueue) and removed from the front (dequeue). It's like a line of people waiting for a bus.",
      useCase: "Queues are used in managing task scheduling in an operating system, handling requests on a web server, and in breadth-first search algorithms for traversing trees and graphs. Printers use a queue to manage print jobs.",
      code: "class Queue {\n  constructor() {\n    this.items = [];\n  }\n\n  enqueue(element) {\n    this.items.push(element);\n  }\n\n  dequeue() {\n    if (this.isEmpty()) return null;\n    return this.items.shift();\n  }\n\n  peek() {\n    if (this.isEmpty()) return null;\n    return this.items[0];\n  }\n\n  isEmpty() {\n    return this.items.length === 0;\n  }\n}\n\n// Usage\nconst queue = new Queue();\nqueue.enqueue(10);\nqueue.enqueue(20);\nconsole.log(queue.peek()); // 10\nconsole.log(queue.dequeue()); // 10",
      questions: [
        {
          question: "How would you implement a queue using two stacks?",
          hint: "One stack for enqueuing, another for dequeuing.",
          answer: "Use two stacks, `s1` and `s2`. For enqueue, push to `s1`. For dequeue, if `s2` is empty, move all elements from `s1` to `s2` then pop from `s2`."
        }
      ]
    },
    {
      id: "linked-list",
      name: "Linked List",
      description: "A linear data structure where elements are not stored in contiguous memory locations",
      definition: "A linked list is a linear data structure where each element is a separate object called a node. Each node contains a data field and a 'next' reference or link to the next node in the sequence. It's a dynamic structure, unlike arrays.",
      useCase: "Linked lists are great for implementing stacks and queues, as well as for managing image viewers where you need to move to the next or previous image. They are also used in web browser history (forward/back) and in some music players.",
      code: "class Node {\n  constructor(data, next = null) {\n    this.data = data;\n    this.next = next;\n  }\n}\n\nclass LinkedList {\n  constructor() {\n    this.head = null;\n  }\n\n  insertFirst(data) {\n    this.head = new Node(data, this.head);\n  }\n\n  size() {\n    let count = 0;\n    let node = this.head;\n    while (node) {\n      count++;\n      node = node.next;\n    }\n    return count;\n  }\n}\n\n// Usage\nconst list = new LinkedList();\nlist.insertFirst(10);\nlist.insertFirst(20);\nconsole.log(list.size()); // 2",
      questions: [
        {
          question: "How do you find the middle element of a singly linked list in a single pass?",
          hint: "Use two pointers, one moving twice as fast as the other.",
          answer: "Use a slow pointer and a fast pointer. The slow pointer moves one step at a time, while the fast pointer moves two. When the fast pointer reaches the end, the slow pointer will be at the middle."
        },
        {
          question: "How do you detect a cycle in a linked list?",
          hint: "Use Floyd's cycle-finding algorithm (tortoise and hare).",
          answer: "Use two pointers, a slow one and a fast one. If they meet at some point, there is a cycle. If the fast pointer reaches the end of the list, there is no cycle."
        }
      ]
    },
    {
      id: "binary-tree",
      name: "Binary Tree",
      description: "A hierarchical data structure with nodes having at most two children",
      definition: "A binary tree is a hierarchical data structure where each node has at most two children, referred to as left and right child. It's a fundamental structure that forms the basis for many advanced data structures like binary search trees, heaps, and expression trees.",
      useCase: "Binary trees are used in database indexing (B-trees), file systems, expression parsing in compilers, decision-making algorithms, and in implementing efficient search algorithms. They're also the foundation for binary search trees which provide O(log n) search, insertion, and deletion operations.",
      code: "class TreeNode {\n  constructor(val) {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nclass BinaryTree {\n  constructor() {\n    this.root = null;\n  }\n\n  // Inorder traversal (Left, Root, Right)\n  inorderTraversal(node = this.root) {\n    if (!node) return [];\n\n    return [\n      ...this.inorderTraversal(node.left),\n      node.val,\n      ...this.inorderTraversal(node.right)\n    ];\n  }\n\n  // Find height of tree\n  getHeight(node = this.root) {\n    if (!node) return 0;\n\n    return 1 + Math.max(\n      this.getHeight(node.left),\n      this.getHeight(node.right)\n    );\n  }\n}\n\n// Usage\nconst tree = new BinaryTree();\ntree.root = new TreeNode(1);\ntree.root.left = new TreeNode(2);\ntree.root.right = new TreeNode(3);\nconsole.log(tree.inorderTraversal()); // [2, 1, 3]",
      questions: [
        {
          question: "How do you find the lowest common ancestor of two nodes?",
          hint: "Use recursive approach - if both nodes are on different sides of current node, current is LCA",
          answer: "Recursively check: if both nodes are in left subtree, recurse left; if both in right, recurse right; otherwise current node is LCA."
        }
      ]
    },
    {
      id: "hash-table",
      name: "Hash Table / Hash Map",
      description: "A data structure that stores key-value pairs for efficient lookup",
      definition: "A hash table is a data structure that uses a hash function to map keys to a specific index in an array. This allows for very fast, average case O(1), insertion, deletion, and lookup operations.",
      useCase: "Hash tables are used everywhere: implementing associative arrays, database indexing, caching systems, and in programming languages for objects or dictionaries. They are also used in cryptography for generating unique identifiers.",
      code: "class HashTable {\n  constructor(size = 53) {\n    this.keyMap = new Array(size);\n  }\n\n  _hash(key) {\n    let total = 0;\n    let WEIRD_PRIME = 31;\n    for (let i = 0; i < Math.min(key.length, 100); i++) {\n      let char = key[i];\n      let value = char.charCodeAt(0) - 96;\n      total = (total * WEIRD_PRIME + value) % this.keyMap.length;\n    }\n    return total;\n  }\n\n  set(key, value) {\n    const index = this._hash(key);\n    if (!this.keyMap[index]) {\n      this.keyMap[index] = [];\n    }\n    this.keyMap[index].push([key, value]);\n  }\n\n  get(key) {\n    const index = this._hash(key);\n    if (this.keyMap[index]) {\n      for (let i = 0; i < this.keyMap[index].length; i++) {\n        if (this.keyMap[index][i][0] === key) {\n          return this.keyMap[index][i][1];\n        }\n      }\n    }\n    return undefined;\n  }\n}\n\n// Usage\nconst ht = new HashTable();\nht.set(\"hello\", \"world\");\nconsole.log(ht.get(\"hello\")); // world",
      questions: [
        {
          question: "Explain collision resolution strategies in a hash table.",
          hint: "There are two main approaches: separate chaining and open addressing.",
          answer: "Separate chaining handles collisions by creating a linked list at each index to store multiple key-value pairs. Open addressing (like linear probing or quadratic probing) finds the next available empty slot in the array."
        }
      ]
    },
    {
      id: "heap",
      name: "Heap",
      description: "A specialized tree-based data structure that satisfies the heap property",
      definition: "A heap is a complete binary tree where each parent node is either always greater than or equal to its child nodes (Max Heap) or less than or equal to its child nodes (Min Heap). It is commonly implemented using an array.",
      useCase: "Heaps are most notably used to implement priority queues, which are essential in scheduling algorithms (e.g., in operating systems) and in algorithms like Dijkstra's for finding the shortest path and Prim's for finding minimum spanning trees.",
      code: "// A basic implementation of a Max Heap\nclass MaxHeap {\n  constructor() {\n    this.heap = [];\n  }\n\n  insert(value) {\n    this.heap.push(value);\n    this.bubbleUp(this.heap.length - 1);\n  }\n\n  bubbleUp(index) {\n    let parentIndex = Math.floor((index - 1) / 2);\n    while (index > 0 && this.heap[index] > this.heap[parentIndex]) {\n      [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n      index = parentIndex;\n      parentIndex = Math.floor((index - 1) / 2);\n    }\n  }\n\n  extractMax() {\n    if (this.heap.length === 0) return null;\n    if (this.heap.length === 1) return this.heap.pop();\n    \n    const max = this.heap[0];\n    this.heap[0] = this.heap.pop();\n    this.bubbleDown(0);\n    return max;\n  }\n  \n  bubbleDown(index) {\n    const leftChildIndex = 2 * index + 1;\n    const rightChildIndex = 2 * index + 2;\n    let largestIndex = index;\n    \n    if (leftChildIndex < this.heap.length && this.heap[leftChildIndex] > this.heap[largestIndex]) {\n      largestIndex = leftChildIndex;\n    }\n    \n    if (rightChildIndex < this.heap.length && this.heap[rightChildIndex] > this.heap[largestIndex]) {\n      largestIndex = rightChildIndex;\n    }\n    \n    if (largestIndex !== index) {\n      [this.heap[index], this.heap[largestIndex]] = [this.heap[largestIndex], this.heap[index]];\n      this.bubbleDown(largestIndex);\n    }\n  }\n}\n\n// Usage\nconst maxHeap = new MaxHeap();\nmaxHeap.insert(41);\nmaxHeap.insert(39);\nmaxHeap.insert(33);\nmaxHeap.insert(18);\nconsole.log(maxHeap.heap); // [41, 39, 33, 18]",
      questions: [
        {
          question: "What is the time complexity for inserting an element into a heap?",
          hint: "Consider the height of the tree.",
          answer: "The time complexity is O(log n), because you only need to traverse from the newly added element up to the root, and the height of a complete binary tree is O(log n)."
        }
      ]
    },
    {
      id: "trie",
      name: "Trie (Prefix Tree)",
      description: "A tree-like data structure used to store a dynamic set of strings",
      definition: "A Trie, or Prefix Tree, is an ordered tree data structure used to store a dynamic set of strings. Each node represents a common prefix, and edges represent characters. Traversing from the root to a node spells out a string prefix.",
      useCase: "Tries are excellent for applications involving autocomplete, spell checkers, and IP routing. Their prefix-based structure allows for very fast searching of a word's existence, typically faster than a hash table in many cases.",
      code: "class TrieNode {\n  constructor() {\n    this.children = {};\n    this.isEndOfWord = false;\n  }\n}\n\nclass Trie {\n  constructor() {\n    this.root = new TrieNode();\n  }\n\n  insert(word) {\n    let current = this.root;\n    for (let i = 0; i < word.length; i++) {\n      const char = word[i];\n      if (!current.children[char]) {\n        current.children[char] = new TrieNode();\n      }\n      current = current.children[char];\n    }\n    current.isEndOfWord = true;\n  }\n\n  search(word) {\n    let current = this.root;\n    for (let i = 0; i < word.length; i++) {\n      const char = word[i];\n      if (!current.children[char]) {\n        return false;\n      }\n      current = current.children[char];\n    }\n    return current.isEndOfWord;\n  }\n}\n\n// Usage\nconst trie = new Trie();\ntrie.insert(\"apple\");\ntrie.insert(\"app\");\nconsole.log(trie.search(\"apple\")); // true\nconsole.log(trie.search(\"app\"));   // true\nconsole.log(trie.search(\"banana\")); // false",
      questions: [
        {
          question: "How does a Trie's space complexity compare to a Hash Table for storing a large list of words?",
          hint: "Consider shared prefixes.",
          answer: "A Trie can be more space-efficient than a Hash Table if the words share common prefixes, as it reuses nodes. However, for a set of words with no shared prefixes, a Trie can be less space-efficient due to the overhead of storing nodes for each character."
        }
      ]
    },
    {
      id: "graph",
      name: "Graph",
      description: "A non-linear data structure consisting of nodes (vertices) and edges",
      definition: "A graph is a non-linear data structure composed of a finite set of vertices (or nodes) and a set of edges connecting these vertices. It can be used to model many real-world networks, from social media connections to city routes.",
      useCase: "Graphs are used extensively in social media networks to represent users and their connections, in Google Maps for finding the shortest path between locations, in logistics for route optimization, and in computer networks.",
      code: "class Graph {\n  constructor() {\n    this.adjacencyList = {};\n  }\n\n  addVertex(vertex) {\n    if (!this.adjacencyList[vertex]) {\n      this.adjacencyList[vertex] = [];\n    }\n  }\n\n  addEdge(v1, v2) {\n    this.adjacencyList[v1].push(v2);\n    this.adjacencyList[v2].push(v1); // For undirected graph\n  }\n\n  removeEdge(v1, v2) {\n    this.adjacencyList[v1] = this.adjacencyList[v1].filter(v => v !== v2);\n    this.adjacencyList[v2] = this.adjacencyList[v2].filter(v => v !== v1);\n  }\n\n  removeVertex(vertex) {\n    while (this.adjacencyList[vertex].length) {\n      const adjacentVertex = this.adjacencyList[vertex].pop();\n      this.removeEdge(vertex, adjacentVertex);\n    }\n    delete this.adjacencyList[vertex];\n  }\n}\n\n// Usage\nconst g = new Graph();\ng.addVertex(\"A\");\ng.addVertex(\"B\");\ng.addEdge(\"A\", \"B\");\nconsole.log(g.adjacencyList); // { A: ['B'], B: ['A'] }",
      questions: [
        {
          question: "Explain the difference between BFS and DFS traversal.",
          hint: "Think about the data structure each algorithm uses to explore nodes.",
          answer: "Breadth-First Search (BFS) explores all neighbor nodes at the present depth before moving on to nodes at the next depth level, typically using a queue. Depth-First Search (DFS) explores as far as possible along each branch before backtracking, typically using a stack or recursion."
        }
      ]
    },
    {
      id: "sorting-algorithms",
      name: "Sorting Algorithms",
      description: "Algorithms for arranging data in a specific order",
      definition: "Sorting algorithms are a set of instructions that takes an array or list as input and reorders its elements in a specific order, such as ascending or descending. Common examples include bubble sort, merge sort, and quicksort.",
      useCase: "Sorting is a foundational operation in computer science. It's used in search algorithms to make them more efficient (e.g., binary search), in database management to organize records, and in graphics for rendering objects in the correct order.",
      code: "// Bubble Sort Example\nfunction bubbleSort(arr) {\n  let len = arr.length;\n  let swapped;\n  do {\n    swapped = false;\n    for (let i = 0; i < len - 1; i++) {\n      if (arr[i] > arr[i + 1]) {\n        let temp = arr[i];\n        arr[i] = arr[i + 1];\n        arr[i + 1] = temp;\n        swapped = true;\n      }\n    }\n  } while (swapped);\n  return arr;\n}\n\n// Usage\nconst numbers = [5, 1, 4, 2, 8];\nconsole.log(bubbleSort(numbers)); // [1, 2, 4, 5, 8]",
      questions: [
        {
          question: "When would you use merge sort over quicksort?",
          hint: "Consider stability and worst-case performance.",
          answer: "Merge sort is a stable, O(n log n) algorithm in all cases, making it a good choice when worst-case performance is a concern. Quicksort has an average O(n log n) but a worst-case O(n^2), although it is often faster in practice due to lower constant factors and in-place sorting."
        }
      ]
    },
    {
      id: "dynamic-programming",
      name: "Dynamic Programming",
      description: "An algorithmic technique for solving complex problems by breaking them into subproblems",
      definition: "Dynamic Programming is an optimization technique used to solve complex problems by breaking them down into smaller, overlapping subproblems. The results of these subproblems are stored (memoization or tabulation) to avoid recomputing them, which significantly improves efficiency.",
      useCase: "DP is used in many areas, including finance for options pricing, bioinformatics for sequence alignment, and in routing algorithms. Classic problems solved with DP include the Fibonacci sequence, the knapsack problem, and the longest common subsequence.",
      code: "// Fibonacci sequence using memoization (top-down DP)\nfunction fib(n, memo = {}) {\n  if (n <= 1) return n;\n  if (memo[n]) return memo[n];\n\n  memo[n] = fib(n - 1, memo) + fib(n - 2, memo);\n  return memo[n];\n}\n\n// Usage\nconsole.log(fib(10)); // 55",
      questions: [
        {
          question: "What are the two key properties a problem must have to be solved with Dynamic Programming?",
          hint: "One is about breaking the problem down, the other is about solving subproblems multiple times.",
          answer: "Optimal substructure, which means an optimal solution to the problem contains optimal solutions to its subproblems. And overlapping subproblems, meaning the same subproblems are solved again and again."
        }
      ]
    }
  ]
};